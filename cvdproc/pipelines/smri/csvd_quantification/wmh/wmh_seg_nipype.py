import os
import subprocess
import shutil
import nibabel as nib
import time
import numpy as np
import pandas as pd
from nipype import Node, Workflow
from nipype.interfaces.base import BaseInterface, BaseInterfaceInputSpec, TraitedSpec, File, Directory, traits, CommandLineInputSpec, File, TraitedSpec, CommandLine, Directory
from nipype.interfaces.utility import IdentityInterface
from traits.api import Bool, Int, Str, Float

from scipy.ndimage import label

'''
Different methods of WMH segmentation
'''

####################
# LST Segmentation #
####################

class LSTSegmentationInputSpec(BaseInterfaceInputSpec):
    matlab_path = Str(mandatory=True, desc="Path to the MATLAB executable")
    spm_path = Str(mandatory=True, desc="Path to the SPM installation")
    seg_script = File(mandatory=True, desc="Path to the LST segmentation script")
    flair_img = File(mandatory=True, desc="Path to the FLAIR image")
    threshold = traits.Float(mandatory=True, desc="Threshold for WMH segmentation") # Here we only expext one threshold value
    output_path = Directory(mandatory=True, desc="Path to the output directory")
    output_mask_name = Str(mandatory=True, desc="Name of the output WMH mask")
    output_prob_map_name = Str(mandatory=True, desc="Name of the output WMH probability map")

class LSTSegmentationOutputSpec(TraitedSpec):
    wmh_mask = File(desc="Path to the WMH mask generated by LST segmentation")
    wmh_prob_map = File(desc="Path to the WMH probability map generated by LST segmentation")

class LSTSegmentation(BaseInterface):
    input_spec = LSTSegmentationInputSpec
    output_spec = LSTSegmentationOutputSpec

    def _run_interface(self, runtime):
        # Create the output directory if it doesn't exist
        os.makedirs(self.inputs.output_path, exist_ok=True)

        binarized_wmh_file_old = os.path.join(self.inputs.output_path, f'bles_{self.inputs.threshold}_lpa_mFLAIR.nii.gz')
        probmap_file_old = os.path.join(self.inputs.output_path, 'ples_lpa_mFLAIR.nii.gz')
        
        binarized_wmh_file = os.path.join(self.inputs.output_path, self.inputs.output_mask_name)
        probmap_file = os.path.join(self.inputs.output_path, self.inputs.output_prob_map_name)

        matlab_command = f"addpath('{self.inputs.spm_path}'); addpath('{os.path.dirname(self.inputs.seg_script)}'); wmh_seg_lst('{self.inputs.flair_img}', {self.inputs.threshold}, '{self.inputs.output_path}'); exit;"

        # If output already exists, skip the segmentation
        if os.path.exists(binarized_wmh_file) and os.path.exists(probmap_file):
            print(f"Output files already exist: {binarized_wmh_file}, {probmap_file}. Skipping segmentation.")
        else:
            cmd = [
                    self.inputs.matlab_path,
                    "-nodesktop",
                    "-nosplash",
                    "-r",
                    f"{matlab_command}"
                ]
            
            subprocess.run(cmd, check=True)

            # rename the output files
            os.rename(binarized_wmh_file_old, binarized_wmh_file)
            os.rename(probmap_file_old, probmap_file)

        # Set the output files
        self._wmh_mask = binarized_wmh_file
        self._wmh_prob_map = probmap_file

        return runtime
    
    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['wmh_mask'] = os.path.abspath(self._wmh_mask)
        outputs['wmh_prob_map'] = os.path.abspath(self._wmh_prob_map)
        
        return outputs

################
# WMH-SynthSeg #
################

from .....utils.python.basic_image_processor import extract_roi_from_image

class WMHSynthSegInputSpec(BaseInterfaceInputSpec):
    flair_img = File(mandatory=True, desc="Path to the FLAIR image")
    output_dir = Directory(mandatory=True, desc="Directory to save the output")
    output_mask_name = Str(mandatory=True, desc="Name of the output WMH mask")
    output_prob_map_name = Str(mandatory=True, desc="Name of the output WMH probability map")
    seg_name = Str(mandatory=True, desc="Name of the segmentation method")

class WMHSynthSegOutputSpec(TraitedSpec):
    wmh_mask = File(desc="Path to the WMH mask generated by WMH-SynthSeg")
    wmh_prob_map = File(desc="Path to the WMH probability map generated by WMH-SynthSeg")
    wmh_synthseg = File(desc="Path to the WMH-SynthSeg output file")

class WMHSynthSeg(BaseInterface):
    input_spec = WMHSynthSegInputSpec
    output_spec = WMHSynthSegOutputSpec

    def _run_interface(self, runtime):
        # Create the output directory if it doesn't exist
        os.makedirs(self.inputs.output_dir, exist_ok=True)

        # prepare the input dir
        input_dir = os.path.join(self.inputs.output_dir, 'input4WMHSynthSeg')
        os.makedirs(input_dir, exist_ok=True)
        shutil.copy(self.inputs.flair_img, input_dir)

        vol_csv = os.path.join(self.inputs.output_dir, 'WMHSynthSegVols.csv')

        # Avoid possible CUDA imcompability issues
        # Here we use the CPU for the segmentation

        # cmd = [
        #     'mri_WMHsynthseg',
        #     '--i', input_dir,
        #     '--o', self.inputs.output_dir,
        #     '--csv_vols', vol_csv,
        #     '--device', 'cuda',
        #     '--crop',
        #     '--save_lesion_probabilities'
        # ]

        cmd = [
            'mri_WMHsynthseg',
            '--i', input_dir,
            '--o', self.inputs.output_dir,
            '--csv_vols', vol_csv,
            '--device', 'cpu',
            '--threads', '8',
            '--save_lesion_probabilities'
        ]

        subprocess.run(cmd, check=True)

        flair_filename = os.path.basename(self.inputs.flair_img).split(".")[0]
        probmap_file_old = os.path.join(self.inputs.output_dir, f'{flair_filename}_seg.lesion_probs.nii.gz')
        seg_file_old = os.path.join(self.inputs.output_dir, f'{flair_filename}_seg.nii.gz')

        seg_file = os.path.join(self.inputs.output_dir, self.inputs.seg_name)
        probmap_file = os.path.join(self.inputs.output_dir, self.inputs.output_prob_map_name)

        os.rename(probmap_file_old, probmap_file)
        os.rename(seg_file_old, seg_file)
        wmh_mask = extract_roi_from_image(seg_file, [77], binarize=True, output_path=os.path.join(self.inputs.output_dir, self.inputs.output_mask_name))

        # Set the output files
        self._wmh_mask = wmh_mask
        self._wmh_prob_map = probmap_file
        self._wmh_synthseg = seg_file

        return runtime
    
    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['wmh_mask'] = os.path.abspath(self._wmh_mask)
        outputs['wmh_prob_map'] = os.path.abspath(self._wmh_prob_map)
        outputs['wmh_synthseg'] = os.path.abspath(self._wmh_synthseg)
        
        return outputs

########################
# truenet segmentation #
########################

class PrepareTrueNetDataInputSpec(CommandLineInputSpec):
    FLAIR = File(desc="FLAIR image path", mandatory=True, argstr='--FLAIR=%s')
    T1 = File(desc="T1 image path", mandatory=True, argstr='--T1=%s')
    outname = Str(desc="Output basename", mandatory=True, argstr='--outname=%s')
    manualmask = File(desc="Manual mask image path", optional=True, argstr='--manualmask=%s')
    nodistmaps = Bool(desc="Skip adding distance maps", default=False, argstr='--nodistmaps')
    keepintermediate = Bool(desc="Keep intermediate results", default=False, argstr='--keepintermediate')
    verbose = Bool(desc="Verbose output", default=False, argstr='-v')

class PrepareTrueNetDataOutputSpec(TraitedSpec):
    output_dir = Directory(desc="Output directory for processed images")
    processed_flair = File(desc="Processed FLAIR image")
    processed_t1 = File(desc="Processed T1 image")

class PrepareTrueNetData(CommandLine):
    input_spec = PrepareTrueNetDataInputSpec
    output_spec = PrepareTrueNetDataOutputSpec
    _cmd = "prepare_truenet_data"

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['output_dir'] = os.path.abspath(os.path.dirname(self.inputs.outname))
        outputs['processed_flair'] = self._gen_output_filename('FLAIR')
        outputs['processed_t1'] = self._gen_output_filename('T1')

        return outputs

    def _gen_output_filename(self, suffix):
        return f"{self.inputs.outname}_{suffix}.nii.gz"


class TrueNetEvaluateInputSpec(CommandLineInputSpec):
    inp_dir = Directory(exists=True, desc="Input directory containing test images", mandatory=True, argstr='-i %s')
    model_name = Str(desc="Pre-trained model name or model path", mandatory=True, argstr='-m %s')
    output_dir = Str(desc="Output directory for saving predictions", mandatory=True, argstr='-o %s')
    use_cpu = Bool(desc="Force the model to evaluate the model on CPU", default=False, argstr='-cpu')
    num_classes = Int(desc="Number of classes in the labels used for training the model", default=2, argstr='-nclass %d')
    intermediate = Bool(desc="Save intermediate predictions", default=False, argstr='-int')
    cp_type = Str(desc="Checkpoint load type", default='last', argstr='-cp_type %s')
    cp_n = Int(desc="If -cp_type=specific, the N value", default=10, argstr='-cp_n %d')
    verbose = Bool(desc="Display debug messages", default=False, argstr='-v')

class TrueNetEvaluateOutputSpec(TraitedSpec):
    output_dir = Directory(desc="Output directory for saving predictions")
    pred_file = File(desc="Path to the predicted file")

class TrueNetEvaluate(CommandLine):
    input_spec = TrueNetEvaluateInputSpec
    output_spec = TrueNetEvaluateOutputSpec
    _cmd = "truenet evaluate"

    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['output_dir'] = os.path.abspath(self.inputs.output_dir)

        # get the prefix in the inp_dir (truenet_preprocess_FLAIR.nii.gz -> truenet_preprocess)
        flair_file = [f for f in os.listdir(self.inputs.inp_dir) if f.endswith('FLAIR.nii.gz')]
        prefix = flair_file[0].split('_FLAIR')[0] if flair_file else None

        if prefix:
            outputs['pred_file'] = os.path.join(self.inputs.output_dir, f"Predicted_probmap_truenet_{prefix}.nii.gz")
        return outputs
    
    
class TrueNetPostProcessInputSpec(BaseInterfaceInputSpec):
    preprocess_dir = Directory(exists=True, desc="Directory containing preprocessed images", mandatory=True)
    pred_file = Str(mandatory=True, desc="Path to the predicted file")
    output_dir = Directory(desc="Output directory for processed images", mandatory=True)
    threshold = Float(mandatory=True, desc="Threshold for WMH segmentation") # Here we only expect one threshold value
    output_mask_name = Str(mandatory=True, desc="Name of the output WMH mask")
    output_prob_map_name = Str(mandatory=True, desc="Name of the output WMH probability map")

class TrueNetPostProcessOutputSpec(TraitedSpec):
    wmh_mask = File(desc="Path to the WMH mask generated by TrueNet")
    wmh_prob_map = File(desc="Path to the WMH probability map generated by TrueNet")

class TrueNetPostProcess(BaseInterface):
    input_spec = TrueNetPostProcessInputSpec
    output_spec = TrueNetPostProcessOutputSpec

    def _run_interface(self, runtime):
        # Create the output directory if it doesn't exist
        os.makedirs(self.inputs.output_dir, exist_ok=True)

        # Load the TrueNet output file
        truenet_output_file = self.inputs.pred_file
        truenet_output_img = nib.load(truenet_output_file)
        truenet_output_data = truenet_output_img.get_fdata()

        # Apply thresholding to create a binary mask
        binary_mask = (truenet_output_data > self.inputs.threshold).astype(np.uint8)

        # Load the WM mask (Match *_WMmask.nii.gz) from the preprocess directory
        wm_mask_file = [f for f in os.listdir(self.inputs.preprocess_dir) if f.endswith('_WMmask.nii.gz')]
        if not wm_mask_file:
            raise FileNotFoundError(f"No WM mask file found in {self.inputs.preprocess_dir}")
        wm_mask_file = os.path.join(self.inputs.preprocess_dir, wm_mask_file[0])
        wm_mask_img = nib.load(wm_mask_file)
        wm_mask_data = wm_mask_img.get_fdata()

        # Get each WMH lesion (use scipy).
        # If a WMH lesion is completely outside the WM mask, it will be removed.
        labeled_mask, num_features = label(binary_mask, structure=np.ones((3, 3, 3)))
        for i in range(1, num_features + 1):
            lesion_mask = (labeled_mask == i).astype(np.uint8)
            lesion_data = lesion_mask * truenet_output_data
            lesion_mean = np.mean(lesion_data[wm_mask_data > 0])
            if lesion_mean == 0:
                binary_mask[labeled_mask == i] = 0

        # Save the binary mask as a NIfTI file
        wmh_mask_file = os.path.join(self.inputs.output_dir, self.inputs.output_mask_name)
        nib.save(nib.Nifti1Image(binary_mask, truenet_output_img.affine), wmh_mask_file)

        # Save the probability map as a NIfTI file
        probmap_file = os.path.join(self.inputs.output_dir, self.inputs.output_prob_map_name)
        os.rename(truenet_output_file, probmap_file)

        # Set the output files
        self._wmh_mask = wmh_mask_file
        self._wmh_prob_map = probmap_file

        return runtime
    
    def _list_outputs(self):
        outputs = self.output_spec().get()
        outputs['wmh_mask'] = os.path.abspath(self._wmh_mask)
        outputs['wmh_prob_map'] = os.path.abspath(self._wmh_prob_map)
        
        return outputs