{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CVDProc: CerebroVascular Disease imaging Processing","text":"<p>Warning</p> <p>This package is intended for research purposes only, to facilitate reproducibility of neuroimaging analyses in our center. The authors do NOT guarantee the correctness or clinical validity of all processing workflows.</p> <p>This repository currently serves as a public display for MRI image preprocessing and analysis, aimed at enhancing the transparency and reproducibility of research conducted at our center.</p>"},{"location":"containers/","title":"Containers used in cvdproc","text":"<p>The containers used in cvdproc are listed below:</p>"},{"location":"containers/#docker-images","title":"Docker Images","text":"<ul> <li>deepmi/lit:0.5.0</li> <li>kilianhett/chp_seg:1.0.1</li> <li>leonyichencai/synb0-disco:v3.1</li> <li>nipreps/fmriprep:v25.1.4</li> <li>pennlinc/aslprep:v25.0.0</li> <li>pennlinc/qsiprep:v1.0.1</li> <li>pennlinc/qsirecon:v1.0.0</li> <li>pennlinc/xcp_d:v0.11.0</li> <li>segcsvd_rc03:latest</li> <li>ytzero/synbold-disco:v1.4</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#download","title":"Download","text":"<p>You can download the source code by cloning the GitHub repository: <pre><code>git clone https://github.com/LuuuXG/cvdproc.git\n</code></pre> Or download it manually from the GitHub homepage.</p>"},{"location":"installation/#installation_1","title":"Installation","text":"<p>Please create a new conda environment, which is more suitable for this package.</p> <pre><code># Please replace &lt;env_name&gt; with the name you want for the environment\nconda create -n &lt;env_name&gt; python=3.7 openssl=1.1.1\nconda activate &lt;env_name&gt;\n</code></pre> <p>Python Version</p> <p>Due to the features of the early version of  SHIVA model, python 3.7 is used for tensorflow compatibility. We are working on updating the code to support higher versions of Python by using SHiVAi. For example, LST-AI for WMH segmentation needs python 3.8 or higher. Currently, the solution is to use a different environment for different pipelines if necessary.</p> <p>Then, navigate to the directory where you downloaded the code (the folder containing <code>setup.py</code>), and run the following command:</p> <pre><code># Use -e to allow modification of the code without needing to reinstall.\n# Here &lt;/path/to/cvdproc&gt; is the folder containing `setup.py`\npip install -e /path/to/cvdproc\n\n# If it is necessary to use mirror\npip install -e /path/to/cvdproc -i https://pypi.tuna.tsinghua.edu.cn/simple\n</code></pre> <p>tensorflow and torch</p> <p>Because these two packages are large in size, we do not specify them in <code>setup.py</code>. However, they will be used in the subsequent code. Please install them as needed.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#1-choroidal-vascular-volume-white-matter-hyperintensity-and-their-interaction-with-cognitive-function-in-aging-adults","title":"1. Choroidal Vascular Volume, White Matter Hyperintensity, and Their Interaction With Cognitive Function in Aging Adults","text":"<p>Choroidal Vascular Volume, White Matter Hyperintensity, and Their Interaction With Cognitive Function in Aging Adults</p> <p>The idea of this study was inspired by SMART-MR series studies (e.g., Keller et al., Ghaznawi et al.). Their work found that shape features of WMH better reflect cognitive decline than traditional volume metrics. We wondered whether the microvascular condition of the eye (assessed by OCTA imaging) is also associated with the shape features of WMH and reflects cognitive function.</p> <p>The code is now implemented in the wmh_quantification pipeline. For WMH segmention, we used the LST-LPA method with FLAIR images. For shape features, the source code is in wmh_shape_nipype.py.</p>"},{"location":"usage/","title":"Usage","text":"<p>Please refer to the different pages for specific functions:</p> <p>If you need to create a BIDS dataset from DICOM files, please refer to:</p> <ul> <li>dcm2bids: Create BIDS dataset from DICOM files.</li> </ul> <p>Or if you already have a dataset in BIDS format, you can use the following functions:</p> <ul> <li>Pipelines: Different pipelines for MRI preprocessing and analysis.</li> </ul>"},{"location":"dcm2bids/dcm2bids/","title":"dcm2bids","text":"<p>We are using the dcm2bids to convert DICOM files to BIDS format. Before running the code, please make sure you have installed the <code>dcm2bids</code> (it should have been installed when you installed the cvdproc) and <code>dcm2niix</code> (you can install it via <code>apt install dcm2niix</code>)</p>"},{"location":"dcm2bids/dcm2bids/#create-a-new-bids-dataset","title":"Create a new BIDS dataset","text":"<p>If you want to create a new BIDS dataset, you can use the following command:</p> <pre><code>cvdproc --run_initialization &lt;path/to/the/folder/you/want/to/create&gt;\n</code></pre> <p>You don't need to create the folder manually, the code will create it for you.</p>"},{"location":"dcm2bids/dcm2bids/#convert-dicom-to-bids","title":"Convert DICOM to BIDS","text":"<p>If you already have a BIDS root folder or just created one with the command above, you can follow the steps below to convert DICOM files to BIDS format.</p>"},{"location":"dcm2bids/dcm2bids/#create-a-dcm2bids-configuration-file","title":"Create a dcm2bids configuration file","text":"<p>Please refer to the official dcm2bids documentation How to create a configuration file for the most detailed guidance.</p> <p>Here we take the example of converting a 3D T1w image to BIDS format.</p> <p>Create a file named <code>dcm2bids_config.json</code> in the <code>code</code> folder of your BIDS root directory (the file name and location can be changed, but we name it this way for convenience). The content of the file is as follows:</p> <pre><code>{\n  \"descriptions\": [\n    {\n      \"datatype\": \"anat\",\n      \"suffix\": \"T1w\",\n      \"criteria\": {\n        \"SeriesDescription\": \"*mprage*\",\n      }\n    }\n  ]\n}\n</code></pre> <p>The most important part of the configuration file is the <code>criteria</code> field, which specifies how to match the DICOM files. In this case, we are matching the <code>SeriesDescription</code> field with a regular expression <code>*mprage*</code>. If your DICOM files do not have this field or have a different value, you can try to use the <code>dcm2bids_helper</code> command to get the information, or you can use <code>dcm2niix</code> (which can also be found in MRIcroGL) to get the information in the JSON file. You can also skip this step (just copy the content above) and wait for the next step to see how we solve it.</p>"},{"location":"dcm2bids/dcm2bids/#create-a-cvdproc-configuration-file","title":"Create a cvdproc configuration file","text":"<p>cvdproc config file</p> <p>This step is very important because it is the core of the <code>cvdproc</code> command to specify parameters.</p> <p>Create a <code>config.yml</code> file in the <code>code</code> folder (note that we use the yaml format), and the content is as follows:</p> <pre><code># You need to specify the BIDS root folder here\nbids_dir: /mnt/f/BIDS/demo_wmh\ndcm2bids: \n  config_file: /mnt/f/BIDS/demo_wmh/code/dcm2bids_config.json # You need to specify the dcm2bids configuration file here\n  # And there are other parameters you can specify:\n  # You can skip these parameters (left as empty) to do nothing additional\n  dwi_fix_bvecbval:\n    - match: \"acq-NODDIb2500_\"\n      bvec: \"/mnt/f/BIDS/demo_wmh/code/bvec.bvec\"\n      bval: \"/mnt/f/BIDS/demo_wmh/code/bval.bval\"\n    - match: \"another_keyword\"\n      bvec: \"/path/to/another/bvec.bvec\"\n      bval: \"/path/to/another/bval.bval\"\n  perf_fix_aslcontext:\n    - match: \"asl\"\n      aslcontext: \"/mnt/f/BIDS/demo_wmh/code/aslcontext.tsv\"\n    - match: \"another_keyword\"\n      aslcontext: \"/path/to/another/aslcontext.tsv\"\n  deface_anat: true\n  fix_intendedfor: true\n</code></pre> <p><code>dwi_fix_bvecbval</code>: It is used in case the bvec and bval information in the DICOM files are incorrect. You can specify multiple matching criteria and corresponding bvec and bval files. The <code>match</code> field is a keyword that will be matched with the file names of the converted NIfTI files (for example, if the DWI sequence has <code>acq-NODDIb2500_</code> in its file name, it will use the specified bvec and bval files to replace the original ones).</p> <p><code>perf_fix_aslcontext</code>: Similar to <code>dwi_fix_bvecbval</code>, it is used when dcm2niix does not generate the correct <code>*_aslcontext.tsv</code> file for ASL images. You can specify multiple matching criteria and corresponding aslcontext files. The <code>match</code> field is a keyword that will be matched with the file names of the converted NIfTI files (for example, if the ASL sequence has <code>asl</code> in its file name, it will use the specified aslcontext file to replace the original one).</p> <p><code>deface_anat</code>: Whether to deface the anatomical images (T1w, T2w, and FLAIR) using FSL. Default is false.</p> <p><code>fix_intendedfor</code>: Whether to fix the <code>IntendedFor</code> field in all .json files. Default is false. This is useful for running nipreps. It will change the <code>IntendedFor</code> field to relative paths (start from ses-). Although it is deprecated in the latest BIDS specification (now, BIDS URI is needed), many nipreps still require it (see this). <p>Remember to change the <code>bids_dir</code> and <code>config_file</code> paths to your own paths. The <code>bids_dir</code> is the root folder of your BIDS dataset, and the <code>config_file</code> is the path to the dcm2bids configuration file you just created. And then you need to move or copy the folder containing the DICOM files for a single subject into the <code>sourcedata</code> folder of the BIDS root directory. For example, if you have a folder named <code>DICOM_01</code> containing the DICOM files for a single subject's baseline acquisition, you need to move or copy it to <code>/mnt/f/BIDS/demo_wmh/sourcedata/DICOM_01</code>. The final folder structure should look like this:</p> <pre><code>/mnt/f/BIDS/demo_wmh\n\u251c\u2500\u2500 code\n\u2502   \u251c\u2500\u2500 config.yml\n\u2502   \u2514\u2500\u2500 dcm2bids_config.json\n\u251c\u2500\u2500 sourcedata\n\u2502   \u2514\u2500\u2500 DICOM_01\n\u2514\u2500\u2500 .bidsignore\n</code></pre> <p>Info</p> <p>Because the original DICOM images obtained in actual research may have different structures, the file structure under the subject's DICOM folder may vary. However, it should be noted that there is no need to preprocess the subfolders under the DICOM folder in advance (for example, a common practice is to make one subfolder correspond to one scanning sequence). This is because <code>dcm2bids</code> will convert all DICOM files found under the folder, even if only a few sequences are specified in the json file (so, for example, when EPI sequences with DWI or multi-echo GRE sequences are included, the conversion time may take several minutes, but fortunately, theoretically, such conversion only needs to be done once).</p> <p>After the above preparation, you need to specify the subject ID and session ID for the converted subject. For example, if the DICOM files are stored in <code>DICOM_01</code>, you need to set the subject ID to <code>SUB0001</code> and the session ID to <code>01</code> to indicate baseline data. Run:</p> <pre><code>cvdproc --config_file /mnt/f/BIDS/demo_wmh/code/config.yml \\\n  --run_dcm2bids \\\n  --subject_id SUB0001 --session_id 01 \\\n  --dicom_subdir DICOM_01\n</code></pre> <p>Theoretically, the folder <code>/mnt/f/BIDS/demo_wmh/sub-SUB0001</code> should be created to store the subject's data. However, since we did not check the <code>SeriesDescription</code> field of the DICOM files in advance, it should prompt that no matching files were found, and the subject folder was not created. Next, we can open the <code>tmp_dcm2bids</code> folder to check the output of <code>dcm2bids</code>, find the json file of the image of interest, and then find the <code>SeriesDescription</code> field (or other fields you want to match) to modify the corresponding content in <code>dcm2bids_config.json</code>, and run the above command again.</p> <p>At this time, it should be able to successfully obtain the <code>sub-SUB0001</code> folder, which contains the <code>ses-01</code> subfolder. Because <code>dcm2bids</code> will automatically look for images that meet the criteria under <code>tmp_dcm2bids</code>, instead of converting all images again.</p>"},{"location":"dcm2bids/dcm2bids/#bidsignore","title":".bidsignore","text":"<p>We can notice that there is a <code>.bidsignore</code> file in the bids root directory, which is used to ignore files that do not belong to the BIDS format. If we open it, we will find that it contains the <code>tmp_dcm2bids</code> folder, which is the temporary folder generated when we run the dcm2bids command. The <code>dcm2bids</code> will automatically add it to the <code>.bidsignore</code>.</p> <p>It is worth noting that <code>dcm2bids</code> itself is very flexible and allows the generation of folders that do not meet the BIDS requirements (for example, I want to change the datatype and suffix in the json file to qsm and GRE respectively, which I believe is not currently specified in the BIDS specification, but this is more convenient for organizing data). In this case, we need to manually add these folders to the <code>.bidsignore</code> (for example: sub-*/ses-*/qsm/ to ignore each qsm folder). This is very necessary because various nipreps (such as fmriprep, qsiprep) include a check bids validation step (although it can be skipped, it is not recommended to do so, otherwise it is easy to have no error but the running process has problems), and these folders that do not meet the standard definition will cause errors.</p> <p>In addition, the BIDSLayout function of nipype seems to automatically exclude folders that do not meet the BIDS definition, regardless of whether they are added to the <code>.bidsignore</code>, which is also why we did not use it.</p>"},{"location":"pipelines/","title":"Pipelines Overview","text":""},{"location":"pipelines/#command-to-run-a-pipeline","title":"Command to Run a Pipeline","text":"<pre><code>cvdproc --config_file &lt;path/to/your/config/file&gt; --run_pipeline --pipeline &lt;pipeline name&gt; --subject_id &lt;subject id (with out -sub prefix)&gt; --session_id &lt;session id (with out -ses prefix)&gt;\n</code></pre> <p>Generally, parameters concerning the pipeline should be set in the configuration file (this configuration file has been mentioned in the dcm2bids section). As we already set the <code>bids_dir</code> parameter in the configuration file, we will need to add some new parameters: <pre><code># For example\nbids_dir: /mnt/f/BIDS/demo_wmh # we have done it in the dcm2bids section\ndcm2bids: \n  config_file: /mnt/f/BIDS/demo_wmh/code/dcm2bids_config.json\n# New things\noutput_dir: /mnt/f/BIDS/demo_wmh/derivatives # output directory, please use bids::/derivatives\npipelines:\n    wmh_quantification: # the pipeline name, can be changed to any available pipeline (see below)\n        # Then the pipeline-specific parameters go here\n        use_which_flair: \"acq-tra\"\n        use_which_t1w: 'acq-highres'\n        seg_threshold: 0.5\n        seg_method: \"LST\"\n        location_method: [\"Fazekas\", \"shiva\", \"McDonald\"]\n        ventmask_method: 'SynthSeg'\n        use_bianca_mask: false\n        normalize_to_mni: true\n</code></pre> The <code>--pipeline</code> parameter is used to specify which pipeline to run. The <code>--subject_id</code> and <code>--session_id</code> parameters are used to specify the subject and session to be processed. You can run multiple subjects and sessions serially by specifying multiple <code>--subject_id</code> and <code>--session_id</code> parameters. For example, if you want to run the <code>wmh_quantification</code> pipeline for subjects <code>SUB0001</code> and <code>SUB0002</code>, both at session <code>01</code>, you can run: <code>cvdproc --config_file /mnt/f/BIDS/demo_wmh/code/config.yml --run_pipeline --pipeline wmh_quantification --subject_id 0001 0002 --session_id 01 01</code>.</p> <p>The detailed parameters for each pipeline can be found in the respective documentation pages (see below). Parameters except for <code>subject</code>, <code>session</code>, and <code>output_path</code> should be set in the configuration file.</p>"},{"location":"pipelines/#currently-available-pipelines","title":"Currently Available Pipelines","text":""},{"location":"pipelines/#structural-mri-smri-pipelines","title":"Structural MRI (sMRI) Pipelines","text":"<ul> <li> Lesion Preprocess (lesion_analysis)</li> <li> Freesurfer recon-all/recon-all-clinical.sh (freesurfer)</li> <li> FSL anat (fsl_anat)</li> <li> T1w Registration to MNI space (t1_register)</li> <li> Anatomical Segmentation (anat_seg)</li> <li> WMH Quantification (wmh_quantification)</li> <li> PVS Quantification (pvs_quantification)</li> <li> CMB Quantification (cmb_quantification)</li> </ul>"},{"location":"pipelines/#diffusion-mri-dmri-pipelines","title":"Diffusion MRI (dMRI) Pipelines","text":"<ul> <li> General DWI Processing (dwi_pipeline)</li> <li> Lesion Quantification Toolkit (LQT) Pipeline (lqt_pipeline)</li> </ul>"},{"location":"pipelines/#functional-mri-fmri-pipelines","title":"Functional MRI (fMRI) Pipelines","text":"<ul> <li> fMRI Pipeline (fmri_pipeline)</li> </ul>"},{"location":"pipelines/#arterial-spin-labeling-asl-pipelines","title":"Arterial Spin Labeling (ASL) Pipelines","text":"<ul> <li> ASL Pipeline (asl_pipeline)</li> </ul>"},{"location":"pipelines/#quantitative-mri-qmri-pipelines","title":"Quantitative MRI (qMRI) Pipelines","text":"<ul> <li> QSM Pipeline (qsm_pipeline)</li> <li> SEPIA QSM (deprecated, archived as a record of the processing used in our paper) (sepia_qsm)</li> </ul>"},{"location":"pipelines/#dsc-mri-pwi-pipelines","title":"DSC-MRI (PWI) Pipelines","text":"<ul> <li> PWI Pipeline (pwi_pipeline)</li> </ul>"},{"location":"pipelines/dMRI/dwi_pipeline/","title":"DWI Pipeline","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#cvdproc.pipelines.dmri.dwi_pipeline.DWIPipeline.__init__","title":"<code>__init__</code>","text":"<p>DWI pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>Subject object</p> required <code>session</code> <code>object</code> <p>Session object</p> required <code>output_path</code> <code>str</code> <p>Output path</p> required <code>use_which_dwi</code> <code>str</code> <p>Which DWI file to use. Defaults to None.</p> <code>None</code> <code>use_which_t1w</code> <code>str</code> <p>Which T1w file to use. Defaults to None.</p> <code>None</code> <code>use_which_flair</code> <code>str</code> <p>Which FLAIR file to use. Defaults to None.</p> <code>None</code> <code>use_freesurfer_longitudinal</code> <code>bool</code> <p>Whether to use FreeSurfer longitudinal processing outpus. Defaults to False.</p> <code>False</code> <code>preprocess</code> <code>bool</code> <p>Whether to preprocess the DWI data. Defaults to False.</p> <code>False</code> <code>output_resolution</code> <code>float</code> <p>Output resolution in mm. Defaults to 2.0.</p> <code>2.0</code> <code>degibbs</code> <code>bool</code> <p>Whether to perform degibbsing. Defaults to True.</p> <code>True</code> <code>flip_b_table_axis</code> <code>list</code> <p>List of axes to flip the b-table. Defaults to []. [0], [1], [2] for x, y, z axes.</p> <code>[]</code> <code>preprocess_method</code> <code>str</code> <p>Preprocessing method. 'fdt', 'mrtrix3' or 'post_qsiprep'. Defaults to 'fdt'.</p> <code>'fdt'</code> <code>synb0</code> <code>bool</code> <p>Whether to use Synb0 for TOPUP. Defaults to False.</p> <code>False</code> <code>use_which_reverse_b0</code> <code>str</code> <p>Which reverse coded b0 image to use. Defaults to None.</p> <code>None</code> <code>dti_fit</code> <code>bool</code> <p>Whether to fit DTI model using FSL dtifit. Defaults to True.</p> <code>False</code> <code>dwi_t1w_register</code> <code>bool</code> <p>Whether to register DWI to T1w space. Defaults to False.</p> <code>False</code> <code>dsistudio_gqi</code> <code>bool</code> <p>Whether to fit GQI model using DSI Studio. Defaults to False.</p> <code>False</code> <code>dsistudio_qsdr</code> <code>bool</code> <p>Whether to fit QSDR model using DSI Studio. Defaults to False.</p> <code>False</code> <code>amico_noddi</code> <code>bool</code> <p>Whether to fit NODDI model using AMICO. Defaults to False.</p> <code>False</code> <code>connectome</code> <code>list</code> <p>Whether to create a connectome (Global). Defaults to []. Subsets of ['fdt', 'mrtrix3', 'dsistudio'].</p> <code>[]</code> <code>tractography</code> <code>list</code> <p>Tractography method (ROI-based). Defaults to []. Subsets of ['fdt', 'mrtrix3', 'dsistudio'].</p> <code>[]</code> <code>seed_mask</code> <code>str</code> <p>Folder name for seed mask. Expected to find /derivatives//sub-/ses-/.nii.gz. Defaults to 'lesion_mask'. Must be in the T1w space. <code>'lesion_mask'</code> <code>use_which_mask</code> <code>str</code> <p>Which mask file to use (in the processed DWI space). Defaults to None.</p> <code>None</code> <code>dtialps</code> <code>bool</code> <p>Whether to perform DTI-ALPS analysis. Defaults to False.</p> <code>False</code> <code>dtialps_register_method</code> <code>int</code> <p>Registration method for DTI-ALPS. 1 for FA + FLIRT, 2 for FA + synthmorph.</p> <code>1</code> <code>pved</code> <code>bool</code> <p>Whether to perform PVeD analysis. Defaults to False.</p> <code>False</code> <code>freewater</code> <code>list</code> <p>List of freewater estimation methods. Defaults to []. Subsets of ['single_shell_freewater', 'markvcid_freewater', 'dti_freewater'].</p> <code>[]</code> <code>psmd</code> <code>bool</code> <p>Whether to perform PSMD analysis. Defaults to False.</p> <code>False</code> <code>psmd_exclude_seed_mask</code> <code>bool</code> <p>Whether to exclude seed mask in PSMD calculation. Defaults to False.</p> <code>False</code> <code>visual_pathway_analysis</code> <code>bool</code> <p>Whether to perform visual pathway analysis. Defaults to False. (An ongoing project! Experimental feature.)</p> <code>False</code> <code>calculate_dwi_metrics</code> <code>bool</code> <p>Whether to calculate DWI scalar maps. Defaults to False.</p> <code>False</code> <code>exclude_seed_mask</code> <code>bool</code> <p>Whether to exclude seed mask in DWI metrics calculation (For NAWM). Defaults to True.</p> <code>True</code> <code>exclude_wmh_mask</code> <code>bool</code> <p>Whether to exclude WMH mask in DWI metrics calculation (For NAWM). Defaults to False.</p> <code>False</code> <code>extract_from</code> <code>str</code> <p>Folder name to extract results from.</p> <code>None</code>"},{"location":"pipelines/dMRI/dwi_pipeline/#cvdproc.pipelines.dmri.dwi_pipeline.DWIPipeline.check_data_requirements","title":"<code>check_data_requirements</code>","text":"<p>check if the required data is available :return: bool</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#a-more-detailed-description","title":"A more detailed description:","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#dwi-preprocessing","title":"DWI Preprocessing","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#single-shell-and-multi-shell-dwi-preprocessing","title":"Single-shell and Multi-shell DWI preprocessing","text":"<p>We use customized scripts to preprocess single-shell and multi-shell DWI data, because current popular DWI preprocessing tools (e.g., MRtrix3, QSIPrep) do not provide an easy way to use Synb0-DISCO for distortion correction when no field map is available.</p> <p>The main steps of our DWI preprocessing pipeline are as follows:</p> <ol> <li>If no reverse phase-encoding (PE) b0 image is available, we use Synb0-DISCO to synthesize the undistorted b0 image from T1w image. Otherwise, we directly use the reverse PE b0 image.</li> <li>Denoise and Gibbs ringing removal (Gibbs ringing removal can be optionally applied).</li> <li>FSL's TOPUP and EDDY for distortion and motion correction, using the real or synthesized reverse PE b0 image.</li> <li>Resample the DWI data to a isotropic voxel size.</li> </ol>"},{"location":"pipelines/dMRI/dwi_pipeline/#dsi-preprocessing","title":"DSI preprocessing","text":"<p>We use QSIPrep for DSI preprocessing. Our DWI Pipeline starts from QSIPrep preprocessed DSI data for further analysis. TOPUP and EDDY-based distortion and motion correction are not suitable for q-space sampling schemes like DSI, this is the reason why we do not employ DSIStudio for DSI preprocessing.</p> <p>Concerning the DSI preprocessing pipeline implemented in QSIPrep is time-consuming (e.g., Very long running time qsiprep processing DSI data), we make some modifications to speed up the process (by running the script qsiprep_single.sh):</p> <ol> <li>Use <code>DRBUDDI_cuda</code> rather than <code>DRBUDDI</code> for distortion correction. Note that <code>DRBUDDI_cuda</code> requires a CUDA-capable GPU. Another change is to set <code>--DRBUDDI_disable_initial_rigid</code> flag to skip the initial rigid registration for a more stable run on PC.</li> <li>Set <code>shoreline-iters</code> to <code>1</code></li> <li>Skip ANTs-based spatial normalization to MNI space by setting <code>--skip-anat-based-spatial-normalization</code> flag. To generate non-linear spatial warps to MNI space (needed for downstream QSIRecon processing), we run a separate registration using mri_synthmorph implemented in Freesurfer 7-dev version.</li> <li>Only use T1w image as anatomical reference. This is ensured by excluding T2w and T2 FLAIR images with nipreps' <code>qsiprep_filter.json</code> file (see How do I select only certain files to be input to fMRIPrep?).</li> </ol> <p>For Chinese readers, notes on using QSIPrep for DSI preprocessing can be found here.</p> <p>If you are interested in replicating our DSI preprocessing pipeline: please first modify QSIPrep's docker file by using a new tortoise.py, then you can reference the script (qsiprep_single.sh) to run QSIPrep for DSI preprocessing (DWI and reverse b0 images in BIDS format, and put Freesurfer <code>license.txt</code>, <code>DRBUDDI_cuda.sh</code> wrapper script, and <code>qsiprep_filter.json</code> in a folder named <code>code</code> in BIDS root directory). </p>"},{"location":"pipelines/dMRI/dwi_pipeline/#reconstruction-of-diffusion-models","title":"Reconstruction of Diffusion Models","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#tensor-model-fitting","title":"Tensor Model Fitting","text":"<p>FSL FDT <code>dtifit</code> is used to fit the diffusion tensor model and calculate DTI-derived metrics, including FA, MD, AD, RD, and tensor mode.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#free-water-elimination-dti-model-fitting","title":"Free Water Elimination DTI Model Fitting","text":"<p>Three available options: - Set 'markvcid_freewater' in <code>freewater</code> (Recommended): MarkVCID2 MRI Free Water (FW). As it has been validated on MarkVCID2 study <sup>1</sup> and external datasets <sup>2</sup>.</p> <ul> <li> <p>Set 'single_shell_freewater' in <code>freewater</code>: Single Shell Free Water Elimination Diffusion Tensor Model</p> </li> <li> <p>Set 'dti_freewater' in <code>freewater</code>: DIPY free water elimination model. Multi-shell DWI data is required for this method. For our clinical analysis, we mainly focus on the free water component rather than the free water-corrected DTI metrics, this method is not that practical as multi-shell DWI can directly use NODDI model to characterize extracellular water distribution (ISO/FW).</p> </li> </ul>"},{"location":"pipelines/dMRI/dwi_pipeline/#noddi-model-fitting","title":"NODDI Model Fitting","text":"<p>AMICO (Accelerated Microstructure Imaging via Convex Optimization) is used to fit the NODDI model and calculate NODDI-derived metrics, including ICVF, ISOVF, and ODI.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#dsi-model-fitting","title":"DSI Model Fitting","text":"<p>DSIStudio is used to reconstruct the diffusion ODFs and calculate DSI-derived metrics, including GFA, QA etc.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#anatomical-processing","title":"Anatomical Processing","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#registration-between-dwi-and-anatomiocal-images-fsnative-and-t1w-space","title":"Registration between DWI and anatomiocal Images (fsnative and T1w space)","text":"<p>While QSIPrep register DWI to T1w space during preprocessing using b0 image, we prefer to use FA map for registration because FA map has better contrast for white matter structures.</p> <p>If corresponding Freesurfer <code>recon-all</code> results are available, some extra processing will be performed for possible subsequent connectome analysis (see below).</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#dwi-derived-metrics","title":"DWI-derived Metrics","text":""},{"location":"pipelines/dMRI/dwi_pipeline/#psmd","title":"PSMD","text":"<p>PSMD (Peak Width of Skeletonized Mean Diffusivity), considered a marker of white matter injury, is calculated using psmd script <sup>3</sup>. We use a previous version of the script, while the latest version prefers a Docker-based implementation.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#dti-alps","title":"DTI-ALPS","text":"<p>DTI-ALPS (Diffusion Tensor Image Analysis along the Perivascular Space) is calculated using a customized script.</p> <p>The original method was proposed in <sup>4</sup>. It is important to note that multiple studies have suggested that DTI-ALPS should not be simply interpreted as a reflection of glymphatic function. Instead, DTI-ALPS likely reflects complex changes in brain microstructure, pointing to a more comprehensive neurodegenerative mechanism <sup>5</sup>.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#pved","title":"PVeD","text":"<p>periventricular diffusivity (PVeD) is proposed as a substitute marker reflecting the glymphatic function in the brain <sup>6</sup>. It is calculated using the official EstPVeD script.</p> <p>Things to concern: A region growing method is used to determine the periventricular region. However, if there are lesions (such as lacunar infarcts with high MD values) in this region, these lesion areas will be ignored, leading to variability in the periventricular region among subjects.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#connectome-analysis","title":"Connectome Analysis","text":"<p>Note</p> <p>FreeSurfer <code>recon-all</code> results are required for this part of analysis.</p>"},{"location":"pipelines/dMRI/dwi_pipeline/#mrtrix3-based-connectome-construction","title":"MRtrix3-based Connectome Construction","text":"<p>Mrtrix3 is recommended for connectome construction. The main steps are as follows:</p> <ol> <li> <p><code>dwi2response dhollander/tournier</code> to estimate the response functions for different tissue types (for single-shell data, only WM response function is estimated).</p> </li> <li> <p><code>dwi2fod msmt_csd/csd</code> to calculate the fiber orientation distributions (FODs) using constrained spherical deconvolution (CSD) (for multi-shell/single-shell data, respectively).</p> </li> <li> <p><code>mtnormalise</code> to perform multi-tissue informed log-domain intensity normalization on FODs.</p> </li> <li> <p><code>5ttgen freesurfer</code> to generate the 5-tissue-type (5TT) image from Freesurfer <code>recon-all</code> results. That's why Freesurfer results are required for this part of analysis. It is convenient to use Freesurfer parcellation as brain atlas for connectome construction, and outperforms <code>5ttgen fsl</code> in our experience (especially for subjects with severe WMH and Lacunes).</p> </li> <li> <p><code>5tt2gmwmi</code> to generate the gray matter-white matter interface (GM-WM interface) from the 5TT image.</p> </li> <li> <p><code>tckgen</code> to generate 1000000 streamlines using the iFOD2 probabilistic tracking algorithm with anatomically constrained tractography (ACT) framework. The GM-WM interface is used as seeding mask.</p> </li> <li> <p><code>tcksift2</code> to compute the cross-sectional area multipliers for each streamline using SIFT2 method.</p> </li> <li> <p><code>tck2connectome</code> to generate the connectome matrix using Freesurfer parcellation as brain atlas (Currently using aparc and aparc+aseg). The connectome weights are set as SIFT2-weighted streamline count.</p> </li> </ol>"},{"location":"pipelines/dMRI/dwi_pipeline/#references","title":"References","text":"<ol> <li> <p>Pauline Maillard, Laura J Hillmer, Hanzhang Lu, Konstantinos Arfanakis, Brian T Gold, Christopher E Bauer, Joel H Kramer, Adam M Staffaroni, Lara Stables, Danny JJ Wang, and others. Mri free water as a biomarker for cognitive performance: validation in the markvcid consortium. Alzheimer's &amp; Dementia: Diagnosis, Assessment &amp; Disease Monitoring, 14(1):e12362, 2022.\u00a0\u21a9</p> </li> <li> <p>Miao Lin, Shuyue Wang, Hui Hong, Yao Zhang, Linyun Xie, Lei Cui, Lingyun Liu, Yeerfan Jiaerken, Xinfeng Yu, Minming Zhang, and others. Longitudinal changes in white matter free water in cerebral small vessel disease: relationship to cerebral blood flow and white matter fiber alterations. Journal of Cerebral Blood Flow &amp; Metabolism, 45(5):932\u2013944, 2025.\u00a0\u21a9</p> </li> <li> <p>Maria Clara Zanon Zotin, Pinar Yilmaz, Lukas Sveikata, Dorothee Schoemaker, Susanne J van Veluw, Mark R Etherton, Andreas Charidimou, Steven M Greenberg, Marco Duering, and Anand Viswanathan. Peak width of skeletonized mean diffusivity: a neuroimaging marker for white matter injury. Radiology, 306(3):e212780, 2023.\u00a0\u21a9</p> </li> <li> <p>Toshiaki Taoka, Yoshitaka Masutani, Hisashi Kawai, Toshiki Nakane, Kiwamu Matsuoka, Fumihiko Yasuno, Toshifumi Kishimoto, and Shinji Naganawa. Evaluation of glymphatic system activity with the diffusion mr technique: diffusion tensor image analysis along the perivascular space (dti-alps) in alzheimer\u2019s disease cases. Japanese journal of radiology, 35(4):172\u2013178, 2017.\u00a0\u21a9</p> </li> <li> <p>Sihui Li, Ruike Chen, Zuozhen Cao, Qinfeng Zhu, Yihan Ma, Keqing Zhu, Zixuan Lin, Dan Wu, and Alzheimer\u2019s Disease Neuroimaging Initiative. Microstructural bias in the assessment of periventricular flow as revealed in postmortem brains. Radiology, 316(3):e250753, 2025.\u00a0\u21a9</p> </li> <li> <p>Chang-Le Chen, Sang Joon Son, Noah Schweitzer, Hecheng Jin, Jinghang Li, Linghai Wang, Shaolin Yang, Chang Hyung Hong, Hyun Woong Roh, Bumhee Park, and others. Periventricular diffusivity reflects apoe $\\varepsilon $4\u2013modulated amyloid accumulation and cognitive impairment in the alzheimer's disease continuum. Alzheimer's &amp; Dementia, 21(9):e70659, 2025.\u00a0\u21a9</p> </li> </ol>"},{"location":"pipelines/dMRI/lqt_pipeline/","title":"LQT Pipeline","text":"<p>Using the Lesion Quantification Toolkit (LQT) to quantify lesion disconnection.</p> <p>Last updated: 2025-08-02, WYJ</p>"},{"location":"pipelines/dMRI/lqt_pipeline/#cvdproc.pipelines.dmri.lqt_pipeline.LQTPipeline.__init__","title":"<code>__init__</code>","text":"<p>LQT Pipeline for lesion disconnection analysis.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>BIDSSubject</code> <p>A BIDS subject object.</p> required <code>session</code> <code>BIDSSession</code> <p>A BIDS session object.</p> required <code>output_path</code> <code>str</code> <p>Directory to save outputs.</p> required <code>seed_mask</code> <code>str</code> <p>Name of the seed mask folder in 'derivatives'. For example, if the ROI mask path is 'derivatives/lesion_mask/sub-XXX/ses-XXX/*infarction.nii.gz', then seed_mask='lesion_mask'.</p> <code>'lesion_mask'</code> <code>use_which_mask</code> <code>str</code> <p>Keyword to select the desired lesion mask. Default is 'infarction'. For example, if the lesion mask is 'derivatives/lesion_mask/sub-XXX/ses-XXX/*infarction.nii.gz', then use_which_mask='infarction'.</p> <code>'infarction'</code> <code>extract_from</code> <code>str</code> <p>If extracting results, please provide it.</p> <code>None</code>"},{"location":"pipelines/dMRI/lqt_pipeline/#cvdproc.pipelines.dmri.lqt_pipeline.LQTPipeline.check_data_requirements","title":"<code>check_data_requirements</code>","text":"<p>Will always return True, as the LQT pipeline will check the seed mask in MNI space during creation of the workflow.</p>"},{"location":"pipelines/dMRI/lqt_pipeline/#a-more-detailed-description","title":"A more detailed description:","text":"<p>Source: LQT</p> <p>Note</p> <p>LQT is implemented in R, so you need to have R installed on your system. Using R in WSL seems to have some instability, try changing the cores=4 parameter in 'cvdproc/pipelines/r/lqt_single_subject.R'.</p> <p>I recommend using the RStudio IDE (because we use rstudioapi in the script) and open 'cvdproc/pipelines/r/lqt_initialize.r' to initialize the LQT package: As the package is no longer being actively maintained, we included the package in 'cvdproc/pipelines/external/LQT' and we can install it from there. Then we need to copy some extension data to the package directory (data is in 'cvdproc/data/lqt/extdata'), which is done in the script. Doing this by following instructions in the LQT README seems incorrect as it will download a MacOS version of DSI Studio, which is not compatible with WSL Linux.</p>"},{"location":"pipelines/pwi/pwi_pipeline/","title":"PWI Pipeline","text":"<p>Postprocessing pipeline for Dynamic Susceptibility Contrast MRI (DSC-MRI) perfusion data (PWI).</p> <p>This pipeline is to: Calculate PWI maps from DSC-MRI data (rCBF, rCBV, MTT, TTP, K2)</p>"},{"location":"pipelines/pwi/pwi_pipeline/#cvdproc.pipelines.pwi.pwi_pipeline.PWIPipeline.__init__","title":"<code>__init__</code>","text":"<p>Postprocessing pipeline for DSC-MRI perfusion data (PWI).</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>BIDSSubject</code> <p>A BIDS subject object.</p> required <code>session</code> <code>BIDSSession</code> <p>A BIDS session object.</p> required <code>output_path</code> <code>str</code> <p>Directory to save outputs.</p> required <code>use_which_pwi</code> <code>str</code> <p>Keyword to select the desired PWI file.</p> <code>'pwi'</code> <code>use_which_t1w</code> <code>str</code> <p>Keyword to select the desired T1w file.</p> <code>None</code> <code>extract_from</code> <code>str</code> <p>If extracting results, please provide it.</p> <code>None</code>"},{"location":"pipelines/pwi/pwi_pipeline/#a-more-detailed-description","title":"A more detailed description:","text":"<ol> <li> <p>Strip the PWI data using SynthStrip to create a brain mask.</p> </li> <li> <p>Calculate the PWI concentration map (a 4D image).</p> </li> <li> <p>Auto select the AIF (arterial input function) from the concentration data. (Please refer to Auto AIF Selection)</p> </li> <li> <p>Generate the perfusion maps (rCBF, rCBV, MTT, TTP, K2) using the MATLAB-based dsc-mri-toolbox.</p> </li> </ol>"},{"location":"pipelines/qMRI/qsm_pipeline/","title":"QSM Pipeline","text":"<p>QSM Processing Pipeline using Sepia and QQNet.</p>"},{"location":"pipelines/qMRI/qsm_pipeline/#cvdproc.pipelines.qmri.qsm_pipeline.QSMPipeline.__init__","title":"<code>__init__</code>","text":"<p>QSM processing pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>BIDSSubject</code> <p>A BIDS subject object.</p> required <code>session</code> <code>BIDSSession</code> <p>A BIDS session object.</p> required <code>output_path</code> <code>str</code> <p>Output directory to save results.</p> required <code>use_which_t1w</code> <code>str</code> <p>Keyword to select the desired T1w image.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, normalize QSM (and other scalar maps) to MNI space via T1w.</p> <code>False</code> <code>phase_image_correction</code> <code>bool</code> <p>If True, apply phase image correction for inter-slice phase polarity differences in the GE data. (https://github.com/kschan0214/sepia/discussions/93)</p> <code>False</code> <code>reverse_phase</code> <code>int</code> <p>Set to 1 to inverse phase polarity (for GE scanners).</p> <code>0</code>"},{"location":"pipelines/qMRI/qsm_pipeline/#a-more-detailed-description","title":"A more detailed description:","text":"<p>This pipeline contains the processing steps to compute Quantitative Susceptibility Mapping (QSM) and other scalar maps from multi-echo gradient echo (GRE) data by the following steps:</p> <ol> <li>QSM reconstruction using a combined approach from the SEPIA toolbox and Chisep toolbox, including:<ul> <li>Phase unwrapping (SEPIA: ROMEO total field calculation)</li> <li>Background field removal using V-SHARP (SEPIA)</li> <li>Dipole inversion using iLSQR (Chisep)</li> </ul> </li> </ol>"},{"location":"pipelines/qMRI/sepia_qsm/","title":"Sepia QSM","text":"<p>Pipeline for processing Quantitative Susceptibility Mapping (QSM) data using the SEPIA toolbox.</p>"},{"location":"pipelines/qMRI/sepia_qsm/#cvdproc.pipelines.qmri.sepia_qsm_pipeline.SepiaQSMPipeline.__init__","title":"<code>__init__</code>","text":"<p>Sepia QSM processing pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>BIDSSubject</code> <p>A BIDS subject object.</p> required <code>session</code> <code>BIDSSession</code> <p>A BIDS session object.</p> required <code>output_path</code> <code>str</code> <p>Output directory to save results.</p> required <code>use_which_t1w</code> <code>str</code> <p>Keyword to select the desired T1w image.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, normalize QSM (and other scalar maps) to MNI space via T1w.</p> <code>False</code> <code>sepia_toolbox_path</code> <code>str</code> <p>Path to the SEPIA toolbox. If None, assumes SEPIA is in MATLAB path.</p> <code>None</code> <code>reverse_phase</code> <code>int</code> <p>Set to 1 to reverse phase polarity (for GE scanners).</p> <code>0</code>"},{"location":"pipelines/qMRI/sepia_qsm/#a-more-detailed-description","title":"A more detailed description:","text":"<p>This pipeline is deprecated. Please use the new QSM pipeline instead.</p> <p>This pipeline contains the processing steps to compute Quantitative Susceptibility Mapping (QSM) from multi-echo gradient echo (GRE) data using the SEPIA toolbox. It is used in our paper: </p> <p>[1] Wang Y, Ye C, Pan R, Tang B, Li C, Liu J, Tao W, Zhang X, Yang T, Yan Y, Jiang S, Lui S, Wu B. Cognitive implications and associated transcriptomic signatures of distinct regional iron depositions in cerebral small vessel disease. Alzheimers Dement. 2025 Apr;21(4):e70196. doi: 10.1002/alz.70196. PMID: 40257048; PMCID: PMC12010275.</p>"},{"location":"pipelines/sMRI/anat_seg/","title":"Anatomical Segmentation","text":""},{"location":"pipelines/sMRI/anat_seg/#cvdproc.pipelines.smri.anat_seg_pipeline.AnatSegPipeline","title":"<code>AnatSegPipeline</code>","text":"<p>Generating anatomical segmentation atlas from sMRI</p>"},{"location":"pipelines/sMRI/anat_seg/#cvdproc.pipelines.smri.anat_seg_pipeline.AnatSegPipeline.__init__","title":"<code>__init__</code>","text":"<p>Generating anatomical segmentation atlas from sMRI</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>Subject object</p> required <code>session</code> <code>object</code> <p>Session object</p> required <code>output_path</code> <code>str</code> <p>Output directory</p> required <code>use_which_t1w</code> <code>str</code> <p>specific string to select T1w image, e.g. 'acq-highres'. If None, T1w image is not used</p> <code>'T1w'</code> <code>methods</code> <code>list</code> <p>List of methods to use. Options include 'synthseg' and 'chpseg'.</p> <code>['synthseg', 'chpseg']</code> <code>cpu_first</code> <code>bool</code> <p>Whether to use CPU first for SynthSeg (if available).</p> <code>False</code> <code>extract_from</code> <code>str</code> <p>Path to extract results from</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments</p> <code>{}</code>"},{"location":"pipelines/sMRI/anat_seg/#a-more-detailed-description","title":"A more detailed description:","text":"<p>In this pipeline, we collect several anatomical segmentation methods for structural MRI (sMRI).</p> <ul> <li>SynthSeg: <code>--keepgeom</code> is set to preserve the original voxel dimension of the input images.</li> <li>chpseg: Using T1w image to segment the choroid plexus (CP) in lateral ventricles.</li> </ul>"},{"location":"pipelines/sMRI/freesurfer/","title":"Freesurfer pipeline","text":""},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.FreesurferClinicalPipeline","title":"<code>FreesurferClinicalPipeline</code>","text":""},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.FreesurferClinicalPipeline.__init__","title":"<code>__init__</code>","text":"<p>Freesurfer clinical pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>The subject object.</p> required <code>session</code> <code>object</code> <p>The session object.</p> required <code>output_path</code> <code>str</code> <p>The output path for the pipeline.</p> required <code>use_which_t1w</code> <code>str</code> <p>Use specific T1w file if multiple are available. Defaults to \"\".</p> <code>''</code>"},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.FreesurferPipeline","title":"<code>FreesurferPipeline</code>","text":"<p>               Bases: <code>FreesurferStatsExtractorMixin</code></p>"},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.FreesurferPipeline.__init__","title":"<code>__init__</code>","text":"<p>Freesurfer pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>Subject object</p> required <code>session</code> <code>object</code> <p>Session object</p> required <code>output_path</code> <code>str</code> <p>Output path</p> required <code>use_which_t1w</code> <code>str</code> <p>Use specific T1w file if multiple are available. Defaults to \"\".</p> <code>''</code> <code>recon_all</code> <code>bool</code> <p>Whether to run recon-all. Defaults to True.</p> <code>True</code> <code>subregion_ha</code> <code>bool</code> <p>Whether to segment hippocampus and amygdala subregions. Defaults to False.</p> <code>False</code> <code>subregion_thalamus</code> <code>bool</code> <p>Whether to segment thalamus subregions. Defaults to False.</p> <code>False</code> <code>subregion_brainstem</code> <code>bool</code> <p>Whether to segment brainstem subregions. Defaults to False.</p> <code>False</code> <code>subregion_hypothalamus</code> <code>bool</code> <p>Whether to segment hypothalamus subunits. Defaults to False.</p> <code>False</code> <code>fsqc</code> <code>bool</code> <p>Whether to run FSQC. Defaults to False.</p> <code>False</code> <code>stats2csv</code> <code>bool</code> <p>Whether to convert stats to CSV. Defaults to False.</p> <code>False</code> <code>extract_from</code> <code>str</code> <p>Path to extract results from. Defaults to \"\".</p> <code>''</code>"},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.SynthSRPipeline","title":"<code>SynthSRPipeline</code>","text":""},{"location":"pipelines/sMRI/freesurfer/#cvdproc.pipelines.smri.freesurfer_pipeline.SynthSRPipeline.__init__","title":"<code>__init__</code>","text":"<p>SynthSR pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>The subject object containing BIDS information.</p> required <code>session</code> <code>object</code> <p>The session object containing BIDS information.</p> required <code>output_path</code> <code>str</code> <p>The output path for the pipeline results.</p> required <code>use_which_t1w</code> <code>str</code> <p>Use specific T1w file if multiple are available. Defaults to \"\".</p> <code>''</code>"},{"location":"pipelines/sMRI/freesurfer/#a-more-detailed-description","title":"A more detailed description:","text":""},{"location":"pipelines/sMRI/freesurfer/#freesurfer-principle-methodological-considerations","title":"Freesurfer: Principle Methodological Considerations","text":""},{"location":"pipelines/sMRI/freesurfer/#freesurfer-version","title":"Freesurfer Version","text":"<p>The current pipeline uses the Freesurfer 7-dev version (freesurfer-linux-ubuntu22_x86_64-dev-20240909-9ca95c6). Although we prefer using deep learning-based tools implemented in Freesurfer 8 for more accurate and robust processing, the 8 version requires a larger RAM. For our groups with limited computational resources, we opt for the 7-dev version and parallelize the processing of multiple subjects to optimize resource usage.</p>"},{"location":"pipelines/sMRI/freesurfer/#external-brain-mask","title":"External Brain Mask","text":"<p>We found that the default brainmask generated by Freesurfer may not be optimal for all datasets. Therefore, we choose to use an external brain mask with <code>mri_synthstrip</code> to replace the brain extraction step. Notably, we take the <code>--no-csf</code> option in <code>mri_synthstrip</code> to avoid misclassifying the CSF as grey matter (see the figure below).</p> <p></p>"},{"location":"pipelines/sMRI/freesurfer/#qcache","title":"qcache","text":"<p>We add the <code>-qcache</code> option to the <code>recon-all</code> command to generate additional surface-based measures.</p>"},{"location":"pipelines/sMRI/freesurfer/#qc","title":"QC","text":"<p>We use fsqc by Deep-MI lab for Freesurfer QC.</p>"},{"location":"pipelines/sMRI/freesurfer/#subfield-segmentation","title":"Subfield Segmentation","text":"<p>The subfield segmentation part includes:</p> <ul> <li>hippocampus and amygdala</li> <li>thalamus</li> <li>brainstem</li> <li>hypothalamus</li> </ul>"},{"location":"pipelines/sMRI/freesurfer/#csv-outputs","title":"CSV Outputs","text":"<p>Although Freesurfer provides <code>aparcstats2table</code> and <code>asegstats2table</code> commands to generate CSV files, we implement our own CSV generation function to have more control over the output format. All <code>.stats</code> files are parsed to generate CSV files (also when subregions stats files are available) for cortical and subcortical measures except for <code>*h.curv.stats</code>.</p>"},{"location":"pipelines/sMRI/freesurfer/#freesurfer-recon-all-clinicalsh","title":"Freesurfer: recon-all-clinical.sh","text":"<p>Some extra preprocessing steps were implemented to achieve output similar to <code>recon-all</code>, such as cortical morphology metrics. For detailed information on these steps, please refer to the source code.</p>"},{"location":"pipelines/sMRI/lesion_analysis/","title":"Lesion Analysis","text":""},{"location":"pipelines/sMRI/lesion_analysis/#cvdproc.pipelines.smri.lesion_analysis_pipeline.LesionAnalysisPipeline","title":"<code>LesionAnalysisPipeline</code>","text":""},{"location":"pipelines/sMRI/lesion_analysis/#cvdproc.pipelines.smri.lesion_analysis_pipeline.LesionAnalysisPipeline.__init__","title":"<code>__init__</code>","text":"<p>Lesion filling pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>Subject object</p> required <code>session</code> <code>object</code> <p>Session object</p> required <code>output_path</code> <code>str</code> <p>Output path</p> required <code>use_which_t1w</code> <code>str</code> <p>Which T1w file to use. Defaults to None.</p> <code>None</code> <code>use_which_lesion_mask</code> <code>str</code> <p>Which lesion mask (T1w space) to use. Defaults to None. Seeks for files in <code>&lt;bids_dir&gt;/derivatives/lesion_mask/sub-&lt;subject_id&gt;/ses-&lt;session_id&gt;</code></p> <code>None</code> <code>lesion_fill</code> <code>bool</code> <p>Whether to perform lesion filling. Defaults to False. Need to be True if <code>out_contra_mask</code> is True.</p> <code>False</code> <code>lesion_fill_method</code> <code>str</code> <p>Lesion filling method. Defaults to 'LIT'. can be 'left-right', 'sym_MNI', or 'LIT'.</p> <code>'LIT'</code> <code>out_contra_mask</code> <code>bool</code> <p>Whether to save contralateral lesion mask when using 'sym_MNI' method. Defaults to False.</p> <code>False</code> <code>lesion_size_analysis</code> <code>bool</code> <p>Whether to perform lesion size analysis (MUST be one cluster). Defaults to True.</p> <code>True</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize lesion mask to MNI space. Defaults to False.</p> <code>False</code> <code>extract_from</code> <code>str</code> <p>Folder name to extract results from. Defaults to None.</p> <code>None</code>"},{"location":"pipelines/sMRI/lesion_analysis/#a-more-detailed-description","title":"A more detailed description:","text":""},{"location":"pipelines/sMRI/lesion_analysis/#lesion-mask","title":"Lesion Mask","text":"<p>A basic consideration is to use T1w structural MRI for the basic processing of lesions. In previous studies, we have tried using DWI for lesion delineation (as acute ischemic stroke lesions are more apparent on DWI), but subsequent neuroimaging analysis often involves image registration, and using low-resolution (and distorted) DWI for registration can introduce significant inaccuracies. Therefore, we currently prefer to manually delineate lesions in T1w space for subsequent analysis.</p> <ul> <li> <p>if output contralateral lesions is desired (<code>out_contra_mask: true</code>): left-right flipped in 'MNI152NLin2009aSym' space and transformed to native space.</p> </li> <li> <p>if normalization is desired (<code>normalize: true</code>): the lesion mask is normalized to the standard 'MNI152NLin6ASym' space.</p> </li> </ul>"},{"location":"pipelines/sMRI/lesion_analysis/#lesion-filling","title":"Lesion Filling","text":"<p>We currently use the Lesion Inpainting Tool (LIT) developed by the Deep-MI team for lesion filling. This functionality can be enabled by setting <code>lesion_fill: true</code> and <code>lesion_fill_method: 'LIT'</code> (requires downloading the docker image: deepmi/lit:0.5.0).</p> <p>Considerations for other lesion filling methods:</p> <ul> <li>KUL_VBG: This method involves ANTs-based registration. It requires a longer time for processing compared to LIT.</li> <li>FSL Lesion Filling: Taking this as a representative example, we found that many other lesion filling methods are based on WMH lesions in MS patients and are not suitable for the brain infarction lesions studied in our research.</li> </ul>"},{"location":"pipelines/sMRI/lesion_analysis/#lesion-size","title":"Lesion Size","text":"<p>Three metrics are commonly used to quantify lesion size (only applicable for single-cluster lesion):</p> <ol> <li> <p>Lesion Volume: The total volume of the lesion in cubic millimeters (mm\u00b3).</p> </li> <li> <p>Max Diameter (Axial): The maximum diameter of the lesion in the axial plane, measured in millimeters (mm).</p> </li> <li> <p>Max Diameter (3D): The maximum diameter of the lesion in three-dimensional space, measured in millimeters (mm).</p> </li> </ol>"},{"location":"pipelines/sMRI/pvs_quantification/","title":"pvs_quantification","text":""},{"location":"pipelines/sMRI/pvs_quantification/#cvdproc.pipelines.smri.csvd_quantification.pvs_pipeline.PVSSegmentationPipeline","title":"<code>PVSSegmentationPipeline</code>","text":""},{"location":"pipelines/sMRI/pvs_quantification/#cvdproc.pipelines.smri.csvd_quantification.pvs_pipeline.PVSSegmentationPipeline.__init__","title":"<code>__init__</code>","text":"<p>PVS Segmentation Pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>object</code> <p>BIDSSubject object</p> required <code>session</code> <code>object</code> <p>BIDSSession object</p> required <code>output_path</code> <code>str</code> <p>output directory for the pipeline</p> required <code>use_which_t1w</code> <code>str</code> <p>specific string to select T1w image, e.g. 'acq-highres'. If None, use the first T1w image found.</p> <code>None</code> <code>use_which_flair</code> <code>str</code> <p>specific string to select FLAIR image, e.g. 'acq-highres'. If None, use the first FLAIR image found.</p> <code>None</code> <code>method</code> <code>str</code> <p>'SHIVA' or 'segcsvd'</p> <code>'segcsvd'</code> <code>modality</code> <code>str</code> <p>'T1w' or 'T1w+FLAIR'. Applicable when method is 'SHIVA'.</p> <code>'T1w'</code> <code>shiva_config</code> <code>str</code> <p>path to SHIVA configuration file. Applicable when method is 'SHIVA'.</p> <code>None</code> <code>use_wmh</code> <code>bool</code> <p>whether to use existing WMH segmentation for PVS segmentation. Applicable when method is 'segcsvd'.</p> <code>False</code> <code>extract_from</code> <code>str</code> <p>path to the output directory from which to extract results. (Currently only for 'segcsvd' outputs)</p> <code>None</code>"},{"location":"pipelines/sMRI/pvs_quantification/#cvdproc.pipelines.smri.csvd_quantification.pvs_pipeline.PVSSegmentationPipeline.check_data_requirements","title":"<code>check_data_requirements</code>","text":"<p>:return: bool</p>"},{"location":"pipelines/sMRI/pvs_quantification/#a-more-detailed-description","title":"A more detailed description:","text":"<p>Current SHiVAi pipeline (2025-06) seems to have problem handling html/pdf reports (for example, when facing NaN value). A workaround is to modify the code in <code>post.py</code> to simply skip the report generation step, which is not critical for the pipeline to run.</p> <pre><code>class SummaryReport(BaseInterface):\n    \"\"\"Make a summary report of preprocessing and prediction\"\"\"\n    input_spec = SummaryReportInputSpec\n    output_spec = SummaryReportOutputSpec\n\n    # def _run_interface(self, runtime):\n    #     \"\"\"\n    #     Build the report for the whole workflow. It contains segmentation statistics and\n    #     quality control figures.\n\n    #     \"\"\"\n    #     if self.inputs.anonymized:\n    #         subject_id = ''\n    #     else:\n    #         subject_id = self.inputs.subject_id\n\n    #     brain_vol_vox = nib.load(self.inputs.brainmask).get_fdata().astype(bool).sum()  # in voxels\n    #     pred_metrics_dict = {}  # Will contain the stats dataframe for each biomarker\n    #     pred_census_im_dict = {}  # Will contain the path to the swarm plot for each biomarker\n    #     pred_overlay_im_dict = {}  # Will contain the path to the figure with biomarkers overlaid on the brain\n    #     models_uid = {}  # Will contain the md5 hash for each file of each predictive model\n    #     pred_and_acq = self.inputs.pred_and_acq\n\n    #     # Generate the distribution figures for each prediction and fill models_uid\n    #     for pred in pred_and_acq:\n    #         lpred = pred.lower()  # \"pred\" is uppercase, so we also need a lowercase version\n    #         if pred == 'LAC':\n    #             name_in_plot = 'Lacuna'\n    #         else:\n    #             name_in_plot = pred\n    #         models_uid[pred] = {}\n    #         pred_metrics_dict[pred] = pd.read_csv(getattr(self.inputs, f'{lpred}_metrics_csv'))\n    #         if pred_metrics_dict[pred]['Number of clusters'].sum() == 0:  # No biomarker detected\n    #             pred_census_im_dict[pred] = None\n    #         else:\n    #             pred_census_im_dict[pred] = violinplot_from_census(getattr(self.inputs, f'{lpred}_census_csv'),\n    #                                                                self.inputs.resolution,\n    #                                                                name_in_plot)\n    #         pred_overlay_im_dict[pred] = getattr(self.inputs, f'{lpred}_overlay')\n    #         ids, url = get_md5_from_json(getattr(self.inputs, f'{lpred}_model_descriptor'), get_url=True)\n    #         models_uid[pred]['id'] = ids\n    #         if url:\n    #             models_uid[pred]['url'] = url\n\n    #     # set optional inputs to None if undefined\n    #     if isdefined(self.inputs.overlayed_brainmask_1):\n    #         overlayed_brainmask_1 = self.inputs.overlayed_brainmask_1\n    #     else:\n    #         overlayed_brainmask_1 = None\n    #     if isdefined(self.inputs.crop_brain_img):\n    #         crop_brain_img = self.inputs.crop_brain_img\n    #     else:\n    #         crop_brain_img = None\n    #     if isdefined(self.inputs.isocontour_slides_FLAIR_T1):\n    #         isocontour_slides_FLAIR_T1 = self.inputs.isocontour_slides_FLAIR_T1\n    #     else:\n    #         isocontour_slides_FLAIR_T1 = None\n    #     if isdefined(self.inputs.overlayed_brainmask_2):\n    #         overlayed_brainmask_2 = self.inputs.overlayed_brainmask_2\n    #     else:\n    #         overlayed_brainmask_2 = None\n    #     if isdefined(self.inputs.wf_graph):\n    #         wf_graph = self.inputs.wf_graph\n    #     else:\n    #         wf_graph = None\n    #     if isdefined(self.inputs.db):\n    #         db = self.inputs.db\n    #     else:\n    #         db = ''\n    #     # process\n    #     html_report = make_report(\n    #         pred_metrics_dict=pred_metrics_dict,\n    #         pred_census_im_dict=pred_census_im_dict,\n    #         pred_overlay_im_dict=pred_overlay_im_dict,\n    #         pred_and_acq=pred_and_acq,\n    #         brain_vol_vox=brain_vol_vox,\n    #         thr_cluster_vals=self.inputs.thr_cluster_vals,\n    #         min_seg_size=self.inputs.min_seg_size,\n    #         models_uid=models_uid,\n    #         bounding_crop=crop_brain_img,\n    #         overlayed_brainmask_1=overlayed_brainmask_1,\n    #         overlayed_brainmask_2=overlayed_brainmask_2,\n    #         isocontour_slides_FLAIR_T1=isocontour_slides_FLAIR_T1,\n    #         subject_id=subject_id,\n    #         image_size=self.inputs.image_size,\n    #         resolution=self.inputs.resolution,\n    #         percentile=self.inputs.percentile,\n    #         threshold=self.inputs.threshold,\n    #         wf_graph=wf_graph\n    #     )\n\n    #     with open('Shiva_report.html', 'w', encoding='utf-8') as fid:\n    #         fid.write(html_report)\n\n    #     # Convert the HTML file to PDF using CSS\n    #     # Creating custom CSSin addition to the main one for the pages header and the logos\n    #     postproc_dir = os.path.dirname(postproc_init)\n    #     css = CSS(os.path.join(postproc_dir, 'printed_styling.css'))\n    #     now = datetime.now(timezone.utc).strftime(\"%Y/%m/%d - %H:%M (UTC)\")\n    #     content_sub_id = f'Patient ID: {subject_id} \\A ' if subject_id else ''\n    #     header = (\n    #         '@page {'\n    #         '   @top-left {'\n    #         f'      content: \"{content_sub_id}Data-base: {db}\";'\n    #         '       font-size: 10pt;'\n    #         '       white-space: pre;'\n    #         '   }'\n    #         '   @top-center {'\n    #         f'      content: \"{now}\";'\n    #         '       font-size: 10pt;'\n    #         '   }'\n    #         '}'\n    #     )\n    #     css_header = CSS(string=header)\n    #     shiva_logo_file = os.path.join(postproc_dir, 'logo_shiva.png')\n    #     other_logos_file = os.path.join(postproc_dir, 'logos_for_shiva.png')\n    #     with open(shiva_logo_file, 'rb') as f:\n    #         image_data = f.read()\n    #         shiva_logo = base64.b64encode(image_data).decode()\n    #     with open(other_logos_file, 'rb') as f:\n    #         image_data = f.read()\n    #         other_logo = base64.b64encode(image_data).decode()\n    #     logo = (\n    #         '@page {'\n    #         '   @bottom-left {'\n    #         f'      background-image: url(data:image/png;base64,{other_logo});'\n    #         '       background-size: 552px 45px;'\n    #         '       display: inline-block;'\n    #         '       width: 560px; '\n    #         '       height: 60px;'\n    #         '       content:\"\";'\n    #         '       background-repeat: no-repeat;'\n    #         '   }'\n    #         '   @top-right-corner {'\n    #         f'      background-image: url(data:image/png;base64,{shiva_logo});'\n    #         '       background-size: 70px 70px;'\n    #         '       display: inline-block;'\n    #         '       width: 70px; '\n    #         '       height: 70px;'\n    #         '       content:\"\";'\n    #         '       background-repeat: no-repeat;'\n    #         '   }'\n    #         '}'\n    #     )\n    #     logo_css = CSS(string=logo)\n    #     HTML('Shiva_report.html').write_pdf('Shiva_report.pdf',\n    #                                         stylesheets=[css, css_header, logo_css])\n\n    #     setattr(self, 'html_report', os.path.abspath('Shiva_report.html'))\n    #     setattr(self, 'pdf_report', os.path.abspath('Shiva_report.pdf'))\n    #     return runtime\n\n    def _run_interface(self, runtime):\n        \"\"\"Skip actual report generation but create placeholder files.\"\"\"\n        print(\"SummaryReport disabled: generating empty HTML and PDF files to avoid workflow errors.\")\n\n        # Create empty HTML file\n        html_path = os.path.abspath('Shiva_report.html')\n        with open(html_path, 'w', encoding='utf-8') as f:\n            f.write('&lt;html&gt;&lt;body&gt;&lt;p&gt;Summary report generation skipped.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;')\n\n        # Create empty (but valid) PDF file header to avoid downstream rendering issues\n        pdf_path = os.path.abspath('Shiva_report.pdf')\n        with open(pdf_path, 'wb') as f:\n            f.write(b'%PDF-1.4\\n%EOF\\n')  # minimal valid PDF structure\n\n        setattr(self, 'html_report', html_path)\n        setattr(self, 'pdf_report', pdf_path)\n        return runtime\n\n\n    def _list_outputs(self):\n        \"\"\"Fill in the output structure.\"\"\"\n        outputs = self.output_spec().trait_get()\n        outputs['html_report'] = getattr(self, 'html_report')\n        outputs['pdf_report'] = getattr(self, 'pdf_report')\n\n        return outputs\n</code></pre>"},{"location":"pipelines/sMRI/t1_register/","title":"Anatomical Segmentation","text":""},{"location":"pipelines/sMRI/t1_register/#cvdproc.pipelines.smri.t1_register.T1RegisterPipeline","title":"<code>T1RegisterPipeline</code>","text":""},{"location":"pipelines/sMRI/t1_register/#cvdproc.pipelines.smri.t1_register.T1RegisterPipeline.__init__","title":"<code>__init__</code>","text":"<p>T1w registration pipeline to register T1w images to MNI space using SynthMorph.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>BIDSSubject</code> <p>A BIDS subject object.</p> required <code>session</code> <code>BIDSSession</code> <p>A BIDS session object.</p> required <code>output_path</code> <code>str</code> <p>Output directory to save results.</p> required <code>use_which_t1w</code> <code>str</code> <p>Keyword to select the desired T1w image.</p> <code>None</code> <code>template_res</code> <code>float</code> <p>Resolution of the MNI template to use (1mm or 0.5mm). Default is 1mm.</p> <code>1</code>"},{"location":"pipelines/sMRI/t1_register/#a-more-detailed-description","title":"A more detailed description:","text":"<p>Synthmorph is used for fast and robust (compared to traditional FNIRT or ANTs methods) T1w to MNI registration.</p>"},{"location":"pipelines/sMRI/wmh_quantification/","title":"WMH Quantification","text":""},{"location":"pipelines/sMRI/wmh_quantification/#cvdproc.pipelines.smri.csvd_quantification.wmh_pipeline.WMHSegmentationPipeline","title":"<code>WMHSegmentationPipeline</code>","text":"<p>WMH Segmentation and Quantification Pipeline</p>"},{"location":"pipelines/sMRI/wmh_quantification/#cvdproc.pipelines.smri.csvd_quantification.wmh_pipeline.WMHSegmentationPipeline.__init__","title":"<code>__init__</code>","text":"<p>WMH Segmentation and Quantification Pipeline</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <p>BIDSSubject object</p> required <code>session</code> <p>BIDSSession object</p> required <code>output_path</code> <p>output directory for the pipeline</p> required <code>use_which_t1w</code> <code>str</code> <p>specific string to select T1w image, e.g. 'acq-highres'. If None, T1w image is not used</p> <code>None</code> <code>use_which_flair</code> <code>str</code> <p>specific string to select FLAIR image, e.g. 'acq-highres'. If None, FLAIR image is not used</p> <code>None</code> <code>seg_method</code> <code>str</code> <p>WMH segmentation method, one of ['LST', 'LSTAI', 'WMHSynthSeg', 'truenet']</p> <code>'LST'</code> <code>seg_threshold</code> <code>float</code> <p>threshold for WMH segmentation (not used for WMHSynthSeg method)</p> <code>0.5</code> <code>location_method</code> <code>list</code> <p>list of location method, subset of ['Fazekas', 'bullseye', 'shiva', 'McDonald', 'JHU']</p> <code>['Fazekas']</code> <code>ventmask_method</code> <code>str</code> <p>method to get ventricle mask, one of ['SynthSeg']</p> <code>'SynthSeg'</code> <code>use_bianca_mask</code> <code>bool</code> <p>whether to use BIANCA white matter mask to constrain WMH segmentation</p> <code>False</code> <code>normalize_to_mni</code> <code>bool</code> <p>whether to normalize the WMH mask to MNI space</p> <code>False</code> <code>shape_features</code> <code>bool</code> <p>whether to calculate shape features for each WMH cluster (need normalize_to_mni=True and location_method contains 'Fazekas')</p> <code>False</code>"},{"location":"pipelines/sMRI/wmh_quantification/#cvdproc.pipelines.smri.csvd_quantification.wmh_pipeline.WMHSegmentationPipeline.check_data_requirements","title":"<code>check_data_requirements</code>","text":"<p>Check data requirements for the pipeline (At least one FLAIR image or T1w image) :return: bool</p>"},{"location":"pipelines/sMRI/wmh_quantification/#a-more-detailed-description","title":"A more detailed description:","text":""},{"location":"pipelines/sMRI/wmh_quantification/#modalities-to-use","title":"modalities to use","text":"<ul> <li>T1w</li> <li>FLAIR</li> </ul> <p>Note on T1w</p> <p>If T1w is provided, make sure it is a 3D T1w image. In the following description, we will not specify whether T1w is 2D or 3D, as we assume T1w is 3D by default.</p> <p>We handle T1w and FLAIR images using the following logic: You can provide either a T1w or a FLAIR image, or both (T1w/FLAIR/T1w+FLAIR). If T1w is provided, the segmentation will be performed on the T1w space (if FLAIR is also provided, FLAIR image will be registered to T1w space and then segmented). The concern here is that if the WMH is segmented on FLAIR image and then transformed to T1w space using a linear registration, the edges of the WMH mask may appear jagged or discontinuous.</p>"},{"location":"pipelines/sMRI/wmh_quantification/#segmentation-methods","title":"segmentation methods","text":"<p>Please refer to the table below for the available segmentation methods and their corresponding modalities and notes.</p> <p>My advice on method selection:</p> <ul> <li>The sensitivity of the methods (especially the ability to detect WMH lesions in the deep white matter). More generally, the nature of the WMH lesions in your dataset (CSVD-related WMH, MS lesions, etc.). For instance, LST-LPA and LST-AI are based on MS data.</li> <li>Whether the method will identify WMH in corpus callosum or not</li> <li>The modalities you have (T1w only, FLAIR only, or both T1w and FLAIR)</li> </ul> <p>Currently, you can only choose one method for WMH segmentation. So a possible way to choose a method is to modify the config file and run the pipeline multiple times with different methods, then compare the results.</p> method name seg_method modalities notes LST-LPA 'LST' (2D/3D) FLAIR / (2D/3D) FLAIR + T1w LST. According to my experience, this method can effectively identify PWMH lesions, but may struggle with smaller DWMH. It is a simple and convenient method for WMH segmentation and is applied in various studies. LST-AI 'LSTAI' (2D/3D) FLAIR + T1w LST-AI. Please specify 'LSTAI' rather than 'LST-AI' in the config file (to avoid extra '-', which conflicts with BIDS style). This method is more sensitive to DWMH detection, but may not identify some PWMH. Additionally, attention should be paid to the selection of thresholds, as the resulting probmap is the average of three models, and many values close to 0.33 or 0.66 may appear in the probmap. WMH-SynthSeg 'WMHSynthSeg' (2D/3D) FLAIR / T1w WMH-SynthSeg. The advantages of this method include the ability to obtain 1mm resolution results, even when the input is 2D FLAIR. However, based on my experience, the segmentation performance varies across different FLAIR sequences, and it may exaggerate WMH. FSL truenet 'truenet' 3D FLAIR / T1w / 3D FLAIR + T1w FSL truenet. The advantages of this method include the provision of multiple models, suitable for single-channel FLAIR and T1w or dual-channel FLAIR + T1w, especially FLAIR + T1w will get very good results, but the preprocessing time is relatively long (because it involves steps such as FAST segmentation). In addition, the preprocessing process seems to have some problems for the case of only FLAIR, and the results obtained without preprocessing when only FLAIR is used are consistent with the results obtained after running preprocessing."},{"location":"pipelines/sMRI/wmh_quantification/#bianca-mask","title":"bianca mask","text":"<p>If 'use_bianca_mask' is set to True, an inclusion mask is applied after the segmentation step (ref: 'The script below creates an example of inclusion mask from T1 images, which excludes cortical GM and the following structures: putamen, globus pallidus, nucleus accumbens, thalamus, brainstem, cerebellum, hippocampus, amygdala. The cortical GM is excluded from the brain mask by extracting the cortical CSF from single-subject\u2019s CSF pve map, dilating it to reach the cortical GM, and excluding these areas. The other structures are identified in MNI space, non-linearly registered to the single-subjects\u2019 images, and removed from the brain mask.' in FSL BIANCA).</p> <p>Other WMH segmentation methods not included in the pipeline:</p> <ul> <li>UBO detector</li> <li>SHiVAi</li> <li>segcsvd</li> <li>MARS-WMH</li> <li>FSL BIANCA: not included because it requires training data</li> </ul>"},{"location":"pipelines/sMRI/wmh_quantification/#lateral-ventricle-mask","title":"lateral ventricle mask","text":"<p>'ventmask_method' is used to specify the method for obtaining the lateral ventricle mask, which is required for the Fazekas location method. You can choose one of the following methods: 'SynthSeg'</p> <ul> <li>'SynthSeg': use SynthSeg</li> </ul>"},{"location":"pipelines/sMRI/wmh_quantification/#location-methods","title":"location methods","text":"<p>You can choose one or more location methods to get the location information of WMH.</p> <ul> <li>'Fazekas': classify WMH into periventricular WMH (PWMH) and deep WMH (DWMH) based on the distance to the lateral ventricles of each WMH cluster. WMH lesions totally outside the 10mm distance to the lateral ventricles are classified as DWMH. Those totally within 10mm distance or partially within 10mm distance are classified as PWMH (Theoretical should be divided into periventricular WMH and confluent WMH, but simplified to PWMH. See this Keller et al. for more information). </li> <li>'bullseye': calculate WMH volume according a bullseye parcellation scheme (see Sudre et al.). Do this classification need precomputed freesurfer recon-all results.</li> <li>'shiva': calculate WMH volume according to the SHIVA parcellation scheme (Shallow, Deep, Perivetricular, Cerebellar, and Brainstem). See shivai for more information.</li> <li>'McDonald': This utilizes the annotation of WMH clusters in LST-AI. It is more suitable for MS lesions.</li> </ul>"},{"location":"pipelines/sMRI/wmh_quantification/#normalization-to-mni-space","title":"normalization to MNI space","text":"<p>If 'normalize_to_mni' is set to True, the WMH segmentation results will be transformed to MNI space using a non-linear registration (SynthMorph).</p>"},{"location":"pipelines/sMRI/wmh_quantification/#shape-features","title":"shape features","text":"<p>If 'shape_features' is set to True, shape features of PWMH and DWMH will be calculated. We refer to the SMART-MR studies (e.g., Keller et al., Ghaznawi et al.) and Han et al.</p> <p>Methodological issues must be considered:</p> <ul> <li>The simple hypothesis is that WMH lesions will be more complex and irregular as they grow larger. However, WMH in different locations may have different growth patterns. For example, a normal aging-related PWMH lesion may reveal a cap-like shape along the lateral ventricle (Fazekas score 1, assume have 4 WMH clusters in left/right anterior/posterior horn of lateral ventricle, respectively), these WMH clusters may grow and merge to a single large PWMH lesion (Fazekas score 3). So, compare the small and large PWMH lesions directly may not be appropriate (in another word, the shape features may dramatically change when two or more WMH clusters merge).</li> <li>If you want to compare the shape features of WMH between different subjects, is it rational to simplely calculate the mean shape features of all WMH clusters in each subject? It seems OK with DWMH clusters, but not for PWMH clusters (see the above point).</li> </ul>"}]}